/*! esm-loader-manager v0.5.1 | (c) 2023 Comandeer | MIT license (see LICENSE) */
import{readdir as t,readFile as n,access as r}from"node:fs/promises";import{cwd as o,env as e}from"node:process";import{fileURLToPath as s,pathToFileURL as a}from"node:url";import{relative as i,isAbsolute as c,resolve as u}from"pathe";const l=[".js",".mjs"];const f=o(),m=await async function n(r){try{if((await t(r)).includes("package.json"))return r;const o=u(r,"..");return o===r?null:n(o)}catch{return null}}(f);null===m&&console.warn("ESMLM: The project root was not detected. Falling back to the CWD.");const d=m??f,h="ESMLM_CONFIG"in e?String(e.ESMLM_CONFIG):await async function n(r,o){try{const e=await t(r);for(const t of l){const n=`.esmlmrc${t}`;if(e.includes(n)){return u(r,n)}}if(r===o)return null;return n(u(r,".."),o)}catch{return null}}(f,d),w=null!==h?u(f,h):null;let p=[];try{if("string"!=typeof w)throw new Error("Invalid path");await r(w);const t=a(w),{default:n}=await import(t.href);p=n.loaders}catch{console.warn("ESMLM: The file with loaders' definition was not found or cannot be accessed.")}async function y(t,n,r){const o=await r(t,n,r),{url:e}=o;if(M(d,o))return o;return p.some((({matcher:t})=>t(e,n)))?{url:e,format:"module"}:o}async function g(t,r,o){const e={...r,url:t};if(M(d,e))return o(t,r,o);const a=p.filter((({matcher:n})=>n(t,r)));if(0===a.length)return o(t,r,o);let i=await async function(t){const r=s(t);return n(r)}(t);for(const{loader:n}of a)i=await n(t,i);return{format:"module",shortCircuit:!0,source:i}}function M(t,n){const r=n.url;return function({url:t,format:n}){return"string"==typeof n?"builtin"===n:t.startsWith("node:")}(n)||/[/\\]node_modules[/\\]/gi.test(r)||!function(t,n){const r=n.startsWith("file://")?s(n):n,o=i(t,r),e=o.length>0,a=!o.startsWith(".."),u=!c(o);return e&&a&&u}(t,r)}export{g as load,y as resolve};
//# sourceMappingURL=esm-loader-manager.mjs.map
